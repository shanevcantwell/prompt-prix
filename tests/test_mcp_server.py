"""Tests for the MCP protocol server (prompt_prix.mcp.server).

Verifies that FastMCP registers the correct tools with correct schemas,
and that tool dispatch reaches the real tool functions.

Does NOT run the stdio transport — uses FastMCP's introspection API.
"""

import asyncio
import pytest

from prompt_prix.mcp.server import mcp


# ─────────────────────────────────────────────────────────────────────
# EXPECTED TOOLS
# ─────────────────────────────────────────────────────────────────────

EXPECTED_TOOL_NAMES = {
    "list_models",
    "complete",
    "calculate_drift",
    "analyze_variants",
    "generate_variants",
    "analyze_trajectory",
    "compare_trajectories",
    "judge",
    "react_step",
}


# ─────────────────────────────────────────────────────────────────────
# TOOL REGISTRATION TESTS
# ─────────────────────────────────────────────────────────────────────

class TestToolRegistration:
    """Verify FastMCP has exactly the expected tools registered."""

    @pytest.mark.asyncio
    async def test_tool_count(self):
        """Server registers exactly 9 tools."""
        tools = await mcp.list_tools()
        assert len(tools) == 9, f"Expected 9 tools, got {len(tools)}: {[t.name for t in tools]}"

    @pytest.mark.asyncio
    async def test_tool_names(self):
        """All expected tool names are present."""
        tools = await mcp.list_tools()
        registered_names = {t.name for t in tools}
        assert registered_names == EXPECTED_TOOL_NAMES

    @pytest.mark.asyncio
    async def test_no_internal_tools_exposed(self):
        """Internal utilities are NOT registered as MCP tools."""
        tools = await mcp.list_tools()
        registered_names = {t.name for t in tools}

        # These are internal — not MCP tools
        internal = {"complete_stream", "build_react_messages", "dispatch_mock",
                     "parse_tool_calls_from_stream", "parse_latency_sentinel"}
        assert registered_names.isdisjoint(internal), \
            f"Internal functions leaked as tools: {registered_names & internal}"


# ─────────────────────────────────────────────────────────────────────
# SCHEMA SPOT-CHECK TESTS
# ─────────────────────────────────────────────────────────────────────

class TestToolSchemas:
    """Spot-check JSON schemas generated by FastMCP from type annotations."""

    @pytest.fixture
    async def tools_by_name(self):
        """Map of tool name → tool object for easy lookup."""
        tools = await mcp.list_tools()
        return {t.name: t for t in tools}

    @pytest.mark.asyncio
    async def test_complete_schema(self, tools_by_name):
        """complete has model_id (required) and temperature (optional with default)."""
        schema = tools_by_name["complete"].inputSchema
        props = schema["properties"]

        assert "model_id" in props
        assert "messages" in props
        assert "temperature" in props
        assert "tools" in props

        # model_id and messages are required
        required = schema.get("required", [])
        assert "model_id" in required
        assert "messages" in required

        # temperature has a default
        assert props["temperature"].get("default") == 0.7

    @pytest.mark.asyncio
    async def test_calculate_drift_schema(self, tools_by_name):
        """calculate_drift has text_a and text_b, both required."""
        schema = tools_by_name["calculate_drift"].inputSchema
        props = schema["properties"]

        assert "text_a" in props
        assert "text_b" in props

        required = schema.get("required", [])
        assert "text_a" in required
        assert "text_b" in required

    @pytest.mark.asyncio
    async def test_react_step_schema(self, tools_by_name):
        """react_step has model_id, system_prompt, trace (list), mock_tools."""
        schema = tools_by_name["react_step"].inputSchema
        props = schema["properties"]

        assert "model_id" in props
        assert "system_prompt" in props
        assert "initial_message" in props
        assert "trace" in props
        assert "mock_tools" in props
        assert "tools" in props

        required = schema.get("required", [])
        assert "model_id" in required
        assert "trace" in required
        assert "mock_tools" in required

    @pytest.mark.asyncio
    async def test_judge_schema(self, tools_by_name):
        """judge has judge_model, response, criteria (all required)."""
        schema = tools_by_name["judge"].inputSchema
        props = schema["properties"]

        assert "judge_model" in props
        assert "response" in props
        assert "criteria" in props

        required = schema.get("required", [])
        assert "judge_model" in required
        assert "response" in required
        assert "criteria" in required

    @pytest.mark.asyncio
    async def test_list_models_schema(self, tools_by_name):
        """list_models has no required parameters."""
        schema = tools_by_name["list_models"].inputSchema
        required = schema.get("required", [])
        assert len(required) == 0

    @pytest.mark.asyncio
    async def test_all_tools_have_descriptions(self, tools_by_name):
        """Every registered tool has a non-empty description."""
        for name, tool in tools_by_name.items():
            assert tool.description, f"Tool {name} has no description"


# ─────────────────────────────────────────────────────────────────────
# DISPATCH ROUND-TRIP TESTS
# ─────────────────────────────────────────────────────────────────────

class TestToolDispatch:
    """Verify that calling tools through FastMCP reaches the real functions."""

    @pytest.mark.asyncio
    async def test_calculate_drift_dispatch(self):
        """call_tool('calculate_drift') reaches the real drift function."""
        import sys
        from unittest.mock import AsyncMock, patch
        from tests.sc_mock import make_semantic_chunker_modules, reset_semantic_chunker

        mock_result = {"drift": 0.42, "interpretation": "Moderate"}
        modules_dict, embeddings_mod = make_semantic_chunker_modules("embeddings")
        embeddings_mod.calculate_drift = AsyncMock(return_value=mock_result)

        with patch.dict(sys.modules, modules_dict):
            reset_semantic_chunker()
            result = await mcp.call_tool(
                "calculate_drift",
                {"text_a": "hello", "text_b": "world"},
            )

        # call_tool returns list or tuple depending on version
        content_list = result[0] if isinstance(result, tuple) else result
        assert len(content_list) >= 1
        assert "0.42" in content_list[0].text

    @pytest.mark.asyncio
    async def test_list_models_dispatch(self):
        """call_tool('list_models') reaches the real list_models function."""
        from unittest.mock import AsyncMock
        from prompt_prix.mcp.registry import register_adapter, clear_adapter

        mock_adapter = AsyncMock()
        mock_adapter.get_available_models = AsyncMock(
            return_value=["model-a", "model-b"]
        )

        register_adapter(mock_adapter)
        try:
            result = await mcp.call_tool("list_models", {})
            # call_tool returns list or tuple depending on version
            content_list = result[0] if isinstance(result, tuple) else result
            assert len(content_list) >= 1
            text = content_list[0].text
            assert "model-a" in text
            assert "model-b" in text
        finally:
            clear_adapter()
